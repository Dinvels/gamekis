<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–æ–π–º–∞–π –º—è—á–∏–∫! - –ö–∏—Å!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            font-family: 'Arial', sans-serif; 
            overflow: hidden; 
            touch-action: none; 
        }
        #gameContainer { 
            position: relative; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden; 
        }
        #gameCanvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            font-size: 24px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); 
            z-index: 10; 
        }
        #pauseBtn { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: rgba(255,255,255,0.2); 
            color: white; 
            border: 2px solid white; 
            border-radius: 10px; 
            padding: 10px 15px; 
            font-size: 18px; 
            cursor: pointer; 
            z-index: 20; 
        }
        #startScreen, #gameOver, #pauseScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 100;
        }
        #gameOver, #pauseScreen { display: none; }
        .game-btn {
            margin: 15px;
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        #quitBtn { background: #ff6b6b; }
        #loading { color: white; font-size: 20px; margin: 20px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <button id="pauseBtn">‚è∏Ô∏è –ü–∞—É–∑–∞</button>
        <div id="ui">üê± –°—á–µ—Ç: <span id="score">0</span></div>
        
        <div id="startScreen">
            <h1>–ü–æ–π–º–∞–π –º—è—á–∏–∫, –∫–∏—Å! üê±</h1>
            <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤...</div>
            <button class="game-btn" onclick="startGame()" id="startBtn" disabled>–ì–æ—Ç–æ–≤–∞, –∫–∏—Å? üòº</button>
        </div>
        
        <div id="pauseScreen">
            <h2>–ü–∞—É–∑–∞</h2>
            <button class="game-btn" onclick="resumeGame()">‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
            <button class="game-btn" onclick="restartGame()">üîÑ –ó–∞–Ω–æ–≤–æ</button>
        </div>
        
        <div id="gameOver">
            <h2>–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! üê±</h2>
            <p>–°—á–µ—Ç: <span id="finalScore">0</span></p>
            <button class="game-btn" onclick="restartGame()">üéÆ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
            <button class="game-btn" id="quitBtn" onclick="closeGame()">üö™ –í—ã–π—Ç–∏</button>
        </div>
    </div>

    <script>
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å –±–æ–Ω—É—Å–∞–º–∏ –∏ –±–æ–º–±–∞–º–∏
        const config = {
            LEVELS: {
                1: { speed: 7, bounces: 10, theme: 'air' },
                2: { speed: 9, bounces: 15, theme: 'air' },
                3: { speed: 11, bounces: 20, theme: 'water' },
                4: { speed: 13, bounces: 25, theme: 'water' },
                5: { speed: 15, bounces: 30, theme: 'earth' }
            },
            POWERUP_CHANCE: 0.2,
            BOMB_CHANCE: 0.1,
            BOMB_CHANCE_AFTER_70: 0.25,
            POWERUP_TYPES: ["expand", "shrink", "slow", "fast", "multi"],
            POWERUP_DURATION: 5000,
            PORTAL_CHANCE: 0.03,
            BALL_TYPES: ["normal", "sticky", "split", "magnetic"]
        };

        // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let canvas, ctx;
        let platform, balls = [], powerups = [], bombs = [], portals = [], particles = [], activePowerups = {};
        let score = 0, currentLevel = 1, gameOver = false, isPaused = false;
        let WIDTH, HEIGHT;
        let keys = {};
        let platformVelocity = 0;
        let resourcesLoaded = false;
        let lastTime = 0;

        // –¶–≤–µ—Ç–∞ –¥–ª—è –±–æ–Ω—É—Å–æ–≤ –∏ –±–æ–º–±
        const POWERUP_COLORS = {
            expand: '#4CAF50',
            shrink: '#F44336',
            slow: '#4CAF50',
            fast: '#F44336',
            multi: '#4CAF50',
            bomb: '#F44336'
        };

        const POWERUP_SYMBOLS = {
            expand: '+',
            shrink: '-',
            slow: '‚Üì',
            fast: '‚Üë',
            multi: 'x2',
            bomb: '!'
        };

        // –¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Ñ–æ–Ω–æ–≤
        const THEME_COLORS = {
            air: ['#87CEEB', '#E0F7FA', '#B3E5FC'],
            water: ['#1E88E5', '#4FC3F7', '#80DEEA'],
            earth: ['#795548', '#8D6E63', '#A1887F'],
            lava: ['#FF5722', '#FF7043', '#FF8A65'],
            space: ['#0D47A1', '#1A237E', '#311B92']
        };

        // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        const images = {
            background1: null,
            background3: null,
            background6: null,
            background10: null,
            background14: null
        };

        const sounds = {
            hit: null,
            music: null,
            bomb: null
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram WebApp
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        async function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            setupCanvas();
            setupControls();
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
            await loadResources();
            resourcesLoaded = true;
            document.getElementById('loading').textContent = "–†–µ—Å—É—Ä—Å—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã!";
            document.getElementById('startBtn').disabled = false;
        }

        function setupCanvas() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            
            window.addEventListener('resize', () => {
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                canvas.width = WIDTH;
                canvas.height = HEIGHT;
            });
        }

        async function loadResources() {
            try {
                // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
                console.log("–ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π...");
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –ø—É—Ç–∏ –∏–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏
                const imagePromises = [
                    loadImage('https://raw.githubusercontent.com/your-username/your-repo/main/generated_image_20251128184952.jpg').then(img => images.background1 = img),
                    loadImage('https://raw.githubusercontent.com/your-username/your-repo/main/1212.jpg').then(img => images.background3 = img),
                    loadImage('https://raw.githubusercontent.com/your-username/your-repo/main/4.jpg').then(img => images.background6 = img),
                    loadImage('https://raw.githubusercontent.com/your-username/your-repo/main/3.jpg').then(img => images.background10 = img),
                    loadImage('https://raw.githubusercontent.com/your-username/your-repo/main/2.jpg').then(img => images.background14 = img)
                ];

                // –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º fallback
                await Promise.allSettled(imagePromises);
                console.log("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã:", images);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å –ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –∏–Ω–∞—á–µ —Å–æ–∑–¥–∞–µ–º fallback
                if (!images.background1) {
                    console.log("–°–æ–∑–¥–∞–µ–º fallback —Ñ–æ–Ω—ã...");
                    createFallbackBackgrounds();
                }
                
                // –ó–∞–≥—Ä—É–∑–∫–∞ –∑–≤—É–∫–æ–≤
                console.log("–ó–∞–≥—Ä—É–∂–∞–µ–º –∑–≤—É–∫–∏...");
                sounds.hit = new Audio('https://raw.githubusercontent.com/your-username/your-repo/main/DP2_Gang_Rim_Hit.wav');
                sounds.music = new Audio('https://raw.githubusercontent.com/your-username/your-repo/main/U.mp3');
                sounds.bomb = new Audio('https://raw.githubusercontent.com/your-username/your-repo/main/DP2_Gang_Rim_Hit.wav');
                
                sounds.hit.volume = 0.7;
                sounds.music.volume = 0.5;
                sounds.music.loop = true;
                sounds.bomb.volume = 0.8;
                
                console.log("–ó–≤—É–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã");
                
            } catch (error) {
                console.log("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤:", error);
                createFallbackBackgrounds();
            }
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    console.log("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ:", src);
                    resolve(img);
                };
                img.onerror = () => {
                    console.log("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:", src);
                    reject(new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å: ${src}`));
                };
                img.src = src;
            });
        }

        function createFallbackBackgrounds() {
            console.log("–°–æ–∑–¥–∞–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ —Ñ–æ–Ω—ã...");
            const createGradientBackground = (color1, color2) => {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createLinearGradient(0, 0, 800, 600);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 800, 600);
                
                return canvas;
            };
            
            images.background1 = createGradientBackground('#0c2461', '#1e3799');
            images.background3 = createGradientBackground('#e55039', '#eb2f06');
            images.background6 = createGradientBackground('#3c6382', '#0a3d62');
            images.background10 = createGradientBackground('#b71540', '#eb2f06');
            images.background14 = createGradientBackground('#0c2461', '#3c6382');
        }

        function setupControls() {
            // –ü–ª–∞–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π - –ò–°–ü–†–ê–í–õ–ï–ù–û
            window.addEventListener('keydown', (e) => {
                if (gameOver || isPaused || !resourcesLoaded) return;
                
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ') {
                    e.preventDefault(); // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ–∫—Ä—É—Ç–∫—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                }
                
                keys[e.key] = true;
                
                if (e.key === ' ' || e.key === 'Escape') {
                    togglePause();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            // –°–µ–Ω—Å–æ—Ä–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            let touchStartX = 0;
            let isMoving = false;
            
            canvas.addEventListener('touchstart', (e) => {
                if (isPaused || !resourcesLoaded) return;
                touchStartX = e.touches[0].clientX;
                isMoving = true;
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (!isMoving || gameOver || isPaused || !resourcesLoaded) return;
                
                const touchX = e.touches[0].clientX;
                const gameX = touchX * (WIDTH / window.innerWidth);
                
                platform.x = Math.max(0, Math.min(WIDTH - platform.width, gameX - platform.width / 2));
                
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', () => {
                isMoving = false;
            });
            
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
        }

        function startGame() {
            if (!resourcesLoaded) return;
            
            document.getElementById('startScreen').style.display = 'none';
            resetGame();
            
            // –ó–∞–ø—É—Å–∫ –º—É–∑—ã–∫–∏
            if (sounds.music) {
                sounds.music.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –º—É–∑—ã–∫—É:", e));
            }
            
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            platform = {
                width: Math.min(150, WIDTH * 0.2),
                height: Math.max(15, HEIGHT * 0.02),
                x: WIDTH/2 - 75,
                y: HEIGHT * 0.85,
                speed: WIDTH * 0.015, // –£–≤–µ–ª–∏—á–∏–ª —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –ª—É—á—à–µ–π –æ—Ç–∑—ã–≤—á–∏–≤–æ—Å—Ç–∏
                color: '#FFB6C1',
                originalWidth: Math.min(150, WIDTH * 0.2),
                originalY: HEIGHT * 0.85
            };

            balls = [{
                x: WIDTH/2,
                y: HEIGHT/3,
                radius: Math.max(10, WIDTH * 0.02),
                dx: config.LEVELS[1].speed * (Math.random() > 0.5 ? 1 : -1),
                dy: config.LEVELS[1].speed,
                color: '#ADD8E6',
                type: 'normal',
                trail: []
            }];

            powerups = [];
            bombs = [];
            portals = [];
            particles = [];
            activePowerups = {};
            score = 0;
            currentLevel = 1;
            gameOver = false;
            isPaused = false;
            platformVelocity = 0;
            keys = {};
            lastTime = 0;
            
            updateUI();
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (!gameOver && !isPaused) {
                update(deltaTime);
                render();
                requestAnimationFrame(gameLoop);
            }
        }

        function update(deltaTime) {
            updatePlatform(deltaTime);
            updateBalls(deltaTime);
            updatePowerups(deltaTime);
            updateBombs(deltaTime);
            updatePortals(deltaTime);
            updateParticles(deltaTime);
            checkBallCollisions();
            
            // –ü–æ–¥–Ω—è—Ç–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∫–∞–∂–¥—ã–µ 50 –æ—á–∫–æ–≤
            updatePlatformPosition();
        }

        function updatePlatform(deltaTime) {
            const acceleration = 0.0005 * deltaTime; // –£–≤–µ–ª–∏—á–∏–ª —É—Å–∫–æ—Ä–µ–Ω–∏–µ
            const friction = 0.92; // –£–º–µ–Ω—å—à–∏–ª —Ç—Ä–µ–Ω–∏–µ –¥–ª—è –±–æ–ª–µ–µ –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è - –ò–°–ü–†–ê–í–õ–ï–ù–û
            if (keys['ArrowLeft']) {
                platformVelocity -= acceleration;
            }
            if (keys['ArrowRight']) {
                platformVelocity += acceleration;
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç—Ä–µ–Ω–∏–µ
            platformVelocity *= friction;
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
            const maxSpeed = platform.speed * 2;
            platformVelocity = Math.max(-maxSpeed, Math.min(maxSpeed, platformVelocity));
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
            platform.x += platformVelocity * (deltaTime / 16);
            platform.x = Math.max(0, Math.min(WIDTH - platform.width, platform.x));
            
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –ø—ã–ª–∏ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏
            if (Math.abs(platformVelocity) > 0.5) {
                createDustParticles();
            }
        }

        function updatePlatformPosition() {
            const maxLift = HEIGHT * 0.3;
            const liftIncrement = maxLift / 10;
            
            const scoreLift = Math.floor(score / 50) * liftIncrement;
            const finalLift = Math.min(maxLift, scoreLift);
            
            platform.y = platform.originalY - finalLift;
        }

        function updateBalls(deltaTime) {
            balls.forEach((ball, index) => {
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–µ–¥
                ball.trail.push({x: ball.x, y: ball.y});
                if (ball.trail.length > 8) {
                    ball.trail.shift();
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
                applyBallBehavior(ball, deltaTime);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
                ball.x += ball.dx * (deltaTime / 16);
                ball.y += ball.dy * (deltaTime / 16);

                // –û—Ç—Å–∫–æ–∫ –æ—Ç —Å—Ç–µ–Ω
                if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= WIDTH) {
                    ball.dx = -ball.dx;
                    createCollisionParticles(ball.x, ball.y, ball.color);
                }
                if (ball.y - ball.radius <= 0) {
                    ball.dy = -ball.dy;
                    createCollisionParticles(ball.x, ball.y, ball.color);
                }

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
                if (ball.y + ball.radius >= platform.y && 
                    ball.y <= platform.y + platform.height &&
                    ball.x >= platform.x && 
                    ball.x <= platform.x + platform.width) {
                    
                    handlePlatformCollision(ball);
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ –ø–æ—Ä—Ç–∞–ª—ã
                checkPortalCollision(ball);

                // –ü—Ä–æ–∏–≥—Ä—ã—à
                if (ball.y > HEIGHT) {
                    balls.splice(index, 1);
                }
            });

            // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã –µ—Å–ª–∏ –Ω–µ—Ç –º—è—á–µ–π
            if (balls.length === 0) {
                gameOver = true;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOver').style.display = 'flex';
                if (sounds.music) {
                    sounds.music.pause();
                }
            }
        }

        function applyBallBehavior(ball, deltaTime) {
            switch(ball.type) {
                case 'sticky':
                    // –õ–∏–ø–∫–∏–π –º—è—á —Å–ª–µ–≥–∫–∞ –ø—Ä–∏—Ç—è–≥–∏–≤–∞–µ—Ç—Å—è –∫ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
                    if (ball.y > HEIGHT / 2) {
                        const dx = platform.x + platform.width/2 - ball.x;
                        ball.dx += dx * 0.0001 * (deltaTime / 16);
                    }
                    break;
                case 'magnetic':
                    // –ú–∞–≥–Ω–∏—Ç–Ω—ã–π –º—è—á –ø—Ä–∏—Ç—è–≥–∏–≤–∞–µ—Ç –¥—Ä—É–≥–∏–µ –º—è—á–∏
                    balls.forEach(otherBall => {
                        if (otherBall !== ball) {
                            const dx = ball.x - otherBall.x;
                            const dy = ball.y - otherBall.y;
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            
                            if (distance < 100 && distance > 0) {
                                const force = 0.3 / (distance * distance) * (deltaTime / 16);
                                otherBall.dx += (dx / distance) * force;
                                otherBall.dy += (dy / distance) * force;
                            }
                        }
                    });
                    break;
            }
        }

        function checkBallCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < ball1.radius + ball2.radius) {
                        // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ –º—è—á–µ–π
                        handleBallCollision(ball1, ball2);
                        createCollisionParticles(
                            (ball1.x + ball2.x) / 2, 
                            (ball1.y + ball2.y) / 2,
                            ball1.color
                        );
                        
                        // –†–∞–∑–¥–µ–ª—è—é—â–∏–π—Å—è –º—è—á
                        if (ball1.type === 'split' && balls.length < 8) {
                            splitBall(ball1);
                        }
                        if (ball2.type === 'split' && balls.length < 8) {
                            splitBall(ball2);
                        }
                    }
                }
            }
        }

        function handleBallCollision(ball1, ball2) {
            // –ü—Ä–æ—Å—Ç–æ–π —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
            const nx = dx / distance;
            const ny = dy / distance;
            
            // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            const dvx = ball2.dx - ball1.dx;
            const dvy = ball2.dy - ball1.dy;
            
            // –°–∫–æ—Ä–æ—Å—Ç—å –≤–¥–æ–ª—å –Ω–æ—Ä–º–∞–ª–∏
            const speed = dvx * nx + dvy * ny;
            
            // –ú—è—á–∏ –Ω–µ —Å—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è, –µ—Å–ª–∏ —É–¥–∞–ª—è—é—Ç—Å—è –¥—Ä—É–≥ –æ—Ç –¥—Ä—É–≥–∞
            if (speed > 0) return;
            
            // –ò–º–ø—É–ª—å—Å —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
            const impulse = 2 * speed / (1/ball1.radius + 1/ball2.radius);
            
            // –ò–∑–º–µ–Ω—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏
            ball1.dx += impulse * nx / ball1.radius;
            ball1.dy += impulse * ny / ball1.radius;
            ball2.dx -= impulse * nx / ball2.radius;
            ball2.dy -= impulse * ny / ball2.radius;
        }

        function splitBall(ball) {
            const newBall1 = {...ball};
            const newBall2 = {...ball};
            
            newBall1.dx = -ball.dx * 0.8;
            newBall1.dy = -ball.dy * 0.8;
            newBall1.radius = ball.radius * 0.7;
            newBall1.trail = [];
            
            newBall2.dx = ball.dx * 0.8;
            newBall2.dy = ball.dy * 0.8;
            newBall2.radius = ball.radius * 0.7;
            newBall2.trail = [];
            
            balls.push(newBall1, newBall2);
            balls.splice(balls.indexOf(ball), 1);
        }

        function handlePlatformCollision(ball) {
            const relativeIntersectX = (platform.x + platform.width / 2) - ball.x;
            const normalizedX = relativeIntersectX / (platform.width / 2);
            const bounceAngle = normalizedX * (Math.PI / 3);

            const currentSpeed = config.LEVELS[currentLevel].speed;
            
            ball.dx = -currentSpeed * Math.sin(bounceAngle);
            ball.dy = -Math.abs(currentSpeed * Math.cos(bounceAngle));

            score++;
            updateUI();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ä–æ–≤–Ω—è
            if (score >= config.LEVELS[currentLevel].bounces && currentLevel < 5) {
                currentLevel++;
                balls.forEach(b => {
                    const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
                    const newSpeed = config.LEVELS[currentLevel].speed;
                    b.dx = (b.dx / speed) * newSpeed;
                    b.dy = (b.dy / speed) * newSpeed;
                });
            }

            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            const maxPlatformWidth = WIDTH * 0.4;
            platform.width = Math.min(maxPlatformWidth, platform.originalWidth * (1 + 0.001 * score));
            
            if (platform.x + platform.width > WIDTH) {
                platform.x = WIDTH - platform.width;
            }

            // –°–º–µ–Ω–∞ —Ü–≤–µ—Ç–æ–≤
            changeColors();

            // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤ –∏ –±–æ–º–±
            const currentBombChance = score >= 70 ? config.BOMB_CHANCE_AFTER_70 : config.BOMB_CHANCE;
            
            if (Math.random() < config.POWERUP_CHANCE && powerups.length < 3) {
                createPowerup(currentBombChance);
            }

            // –°–ª—É—á–∞–π–Ω–∞—è —Å–º–µ–Ω–∞ —Ç–∏–ø–∞ –º—è—á–∞
            if (Math.random() < 0.08 && balls.length === 1) {
                ball.type = config.BALL_TYPES[Math.floor(Math.random() * config.BALL_TYPES.length)];
            }

            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ—Ä—Ç–∞–ª–æ–≤
            if (Math.random() < config.PORTAL_CHANCE && portals.length < 2) {
                createPortal();
            }

            playHitSound();
        }

        function changeColors() {
            // –ü—Ä–æ—Å—Ç–∞—è —Å–º–µ–Ω–∞ —Ü–≤–µ—Ç–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏ –º—è—á–µ–π
            const colors = ['#FFB6C1', '#ADD8E6', '#98FB98', '#DDA0DD', '#F0E68C'];
            platform.color = colors[score % colors.length];
            
            const ballColors = ['#ADD8E6', '#FFB6C1', '#98FB98', '#DDA0DD'];
            balls.forEach(ball => {
                ball.color = ballColors[(score + 1) % ballColors.length];
            });
        }

        function createPowerup(bombChance) {
            const powerupSize = Math.max(15, WIDTH * 0.03);
            let type;
            
            if (Math.random() < bombChance) {
                type = "bomb";
            } else {
                type = config.POWERUP_TYPES[Math.floor(Math.random() * config.POWERUP_TYPES.length)];
            }
            
            if (type === "bomb") {
                bombs.push({
                    x: Math.random() * (WIDTH - powerupSize * 2) + powerupSize,
                    y: 0,
                    type: type,
                    speed: 3,
                    size: powerupSize,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            } else {
                powerups.push({
                    x: Math.random() * (WIDTH - powerupSize * 2) + powerupSize,
                    y: 0,
                    type: type,
                    speed: 2,
                    size: powerupSize
                });
            }
        }

        function createPortal() {
            const portalSize = Math.max(30, WIDTH * 0.05);
            const side = Math.random() > 0.5 ? 'left' : 'right';
            
            portals.push({
                x: side === 'left' ? portalSize : WIDTH - portalSize,
                y: Math.random() * (HEIGHT * 0.6) + HEIGHT * 0.2,
                size: portalSize,
                side: side,
                rotation: 0,
                pair: null
            });
            
            // –°–æ–∑–¥–∞–µ–º –ø–∞—Ä–Ω—ã–π –ø–æ—Ä—Ç–∞–ª
            if (portals.length >= 2) {
                const portal1 = portals[portals.length - 2];
                const portal2 = portals[portals.length - 1];
                portal1.pair = portal2;
                portal2.pair = portal1;
            }
        }

        function updatePowerups(deltaTime) {
            // –î–≤–∏–∂–µ–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤
            powerups.forEach((powerup, index) => {
                powerup.y += powerup.speed * (deltaTime / 16);

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
                if (powerup.y + powerup.size >= platform.y && 
                    powerup.y <= platform.y + platform.height &&
                    powerup.x >= platform.x && 
                    powerup.x <= platform.x + platform.width) {
                    
                    activatePowerup(powerup.type);
                    powerups.splice(index, 1);
                }

                // –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º
                if (powerup.y > HEIGHT) {
                    powerups.splice(index, 1);
                }
            });

            // –î–≤–∏–∂–µ–Ω–∏–µ –±–æ–º–±
            bombs.forEach((bomb, index) => {
                bomb.y += bomb.speed * (deltaTime / 16);

                // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π
                if (bomb.y + bomb.size >= platform.y && 
                    bomb.y <= platform.y + platform.height &&
                    bomb.x >= platform.x && 
                    bomb.x <= platform.x + platform.width) {
                    
                    // –í–∑—Ä—ã–≤ –±–æ–º–±—ã - –ø—Ä–æ–∏–≥—Ä—ã—à
                    playBombSound();
                    gameOver = true;
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('gameOver').style.display = 'flex';
                    if (sounds.music) {
                        sounds.music.pause();
                    }
                }

                // –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º
                if (bomb.y > HEIGHT) {
                    bombs.splice(index, 1);
                }
            });

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ–Ω—É—Å–æ–≤
            const now = Date.now();
            Object.keys(activePowerups).forEach(type => {
                if (now > activePowerups[type]) {
                    deactivatePowerup(type);
                    delete activePowerups[type];
                }
            });
        }

        function updateBombs(deltaTime) {
            // –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –±–æ–º–±
            bombs.forEach(bomb => {
                bomb.pulsePhase += 0.05 * (deltaTime / 16);
            });
        }

        function updatePortals(deltaTime) {
            portals.forEach(portal => {
                portal.rotation += 0.02 * (deltaTime / 16);
            });
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ—Ä—Ç–∞–ª—ã
            if (portals.length > 4) {
                portals.splice(0, 2);
            }
        }

        function checkPortalCollision(ball) {
            portals.forEach(portal => {
                const dx = ball.x - portal.x;
                const dy = ball.y - portal.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < portal.size / 2 + ball.radius && portal.pair) {
                    // –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º –º—è—á
                    ball.x = portal.pair.x;
                    ball.y = portal.pair.y;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å, –Ω–æ –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞
                    const speed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                    const angle = Math.atan2(ball.dy, ball.dx) + (Math.random() - 0.5) * 0.5;
                    ball.dx = Math.cos(angle) * speed;
                    ball.dy = Math.sin(angle) * speed;
                    
                    createTeleportParticles(ball.x, ball.y);
                }
            });
        }

        function createCollisionParticles(x, y, color) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 1,
                    color: color,
                    size: Math.random() * 2 + 1
                });
            }
        }

        function createDustParticles() {
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: platform.x + Math.random() * platform.width,
                    y: platform.y + platform.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    life: 1,
                    color: '#CCCCCC',
                    size: Math.random() * 2 + 1
                });
            }
        }

        function createTeleportParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    color: '#9C27B0',
                    size: Math.random() * 3 + 2
                });
            }
        }

        function updateParticles(deltaTime) {
            particles.forEach((particle, index) => {
                particle.x += particle.vx * (deltaTime / 16);
                particle.y += particle.vy * (deltaTime / 16);
                particle.life -= 0.02 * (deltaTime / 16);
                
                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }

        function activatePowerup(type) {
            const duration = config.POWERUP_DURATION;
            activePowerups[type] = Date.now() + duration;

            switch(type) {
                case 'expand':
                    platform.width = Math.min(WIDTH * 0.4, platform.width * 1.5);
                    break;
                case 'shrink':
                    platform.width = Math.max(WIDTH * 0.1, platform.width * 0.7);
                    break;
                case 'slow':
                    balls.forEach(ball => {
                        ball.dx *= 0.7;
                        ball.dy *= 0.7;
                    });
                    break;
                case 'fast':
                    balls.forEach(ball => {
                        ball.dx *= 1.3;
                        ball.dy *= 1.3;
                    });
                    break;
                case 'multi':
                    if (balls.length < 5) {
                        for (let i = 0; i < 2 && balls.length < 5; i++) {
                            const newBall = {...balls[0]};
                            newBall.dx = -newBall.dx * (0.8 + Math.random() * 0.4);
                            newBall.color = '#98FB98';
                            newBall.trail = [];
                            balls.push(newBall);
                        }
                    }
                    break;
            }
        }

        function deactivatePowerup(type) {
            switch(type) {
                case 'expand':
                case 'shrink':
                    platform.width = platform.originalWidth * (1 + 0.001 * score);
                    break;
                case 'slow':
                case 'fast':
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
                    const currentSpeed = config.LEVELS[currentLevel].speed;
                    balls.forEach(ball => {
                        const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        ball.dx = (ball.dx / speed) * currentSpeed;
                        ball.dy = (ball.dy / speed) * currentSpeed;
                    });
                    break;
            }
        }

        function render() {
            // –§–æ–Ω —Å —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ —Ü–≤–µ—Ç–∞–º–∏ –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
            const theme = config.LEVELS[currentLevel].theme;
            
            // –ü—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –æ–Ω–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
            let backgroundUsed = false;
            
            if (currentLevel >= 14 && images.background14) {
                ctx.drawImage(images.background14, 0, 0, WIDTH, HEIGHT);
                backgroundUsed = true;
            } else if (currentLevel >= 10 && images.background10) {
                ctx.drawImage(images.background10, 0, 0, WIDTH, HEIGHT);
                backgroundUsed = true;
            } else if (currentLevel >= 6 && images.background6) {
                ctx.drawImage(images.background6, 0, 0, WIDTH, HEIGHT);
                backgroundUsed = true;
            } else if (currentLevel >= 3 && images.background3) {
                ctx.drawImage(images.background3, 0, 0, WIDTH, HEIGHT);
                backgroundUsed = true;
            } else if (images.background1) {
                ctx.drawImage(images.background1, 0, 0, WIDTH, HEIGHT);
                backgroundUsed = true;
            }
            
            // –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç
            if (!backgroundUsed) {
                const colors = THEME_COLORS[theme] || THEME_COLORS.air;
                const gradient = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
                gradient.addColorStop(0, colors[0]);
                gradient.addColorStop(0.5, colors[1]);
                gradient.addColorStop(1, colors[2]);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
            }

            // –ß–∞—Å—Ç–∏—Ü—ã
            particles.forEach(particle => {
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // –ü–æ—Ä—Ç–∞–ª—ã
            portals.forEach(portal => {
                ctx.save();
                ctx.translate(portal.x, portal.y);
                ctx.rotate(portal.rotation);
                
                ctx.strokeStyle = '#9C27B0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, portal.size / 2, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(156, 39, 176, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, portal.size / 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });
            
            // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
            ctx.fillStyle = platform.color;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            
            // –ú—è—á–∏ —Å —Å–ª–µ–¥–∞–º–∏
            balls.forEach(ball => {
                // –°–ª–µ–¥
                ball.trail.forEach((point, index) => {
                    const alpha = index / ball.trail.length * 0.4;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = ball.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, ball.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // –ú—è—á
                ctx.fillStyle = ball.color;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();

                // –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ç–∏–ø–∞ –º—è—á–∞
                if (ball.type !== 'normal') {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `bold ${ball.radius}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    let symbol = '‚óè';
                    switch(ball.type) {
                        case 'sticky': symbol = 'S'; break;
                        case 'split': symbol = 'D'; break;
                        case 'magnetic': symbol = 'M'; break;
                    }
                    
                    ctx.fillText(symbol, ball.x, ball.y);
                }
            });

            // –ë–æ–Ω—É—Å—ã
            powerups.forEach(powerup => {
                ctx.fillStyle = POWERUP_COLORS[powerup.type];
                ctx.fillRect(powerup.x, powerup.y, powerup.size, powerup.size);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(POWERUP_SYMBOLS[powerup.type], powerup.x + powerup.size/2, powerup.y + powerup.size/2);
            });

            // –ë–æ–º–±—ã
            bombs.forEach(bomb => {
                const pulseScale = 1 + 0.1 * Math.sin(bomb.pulsePhase);
                const currentSize = bomb.size * pulseScale;
                
                ctx.fillStyle = POWERUP_COLORS.bomb;
                ctx.beginPath();
                ctx.arc(bomb.x + bomb.size/2, bomb.y + bomb.size/2, currentSize/2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('!', bomb.x + bomb.size/2, bomb.y + bomb.size/2);
            });
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
        }

        function playHitSound() {
            if (sounds.hit) {
                sounds.hit.currentTime = 0;
                sounds.hit.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–≤—É–∫ —É–¥–∞—Ä–∞"));
            }
        }

        function playBombSound() {
            if (sounds.bomb) {
                sounds.bomb.currentTime = 0;
                sounds.bomb.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–≤—É–∫ –≤–∑—Ä—ã–≤–∞"));
            }
        }

        function togglePause() {
            if (!resourcesLoaded) return;
            
            isPaused = !isPaused;
            document.getElementById('pauseScreen').style.display = isPaused ? 'flex' : 'none';
            
            if (sounds.music) {
                if (isPaused) {
                    sounds.music.pause();
                } else {
                    sounds.music.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å –º—É–∑—ã–∫—É"));
                }
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseScreen').style.display = 'none';
            if (sounds.music) {
                sounds.music.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å –º—É–∑—ã–∫—É"));
            }
            lastTime = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è
            requestAnimationFrame(gameLoop);
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            resetGame();
            if (sounds.music) {
                sounds.music.play().catch(e => console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –º—É–∑—ã–∫—É"));
            }
            lastTime = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è
            requestAnimationFrame(gameLoop);
        }

        function closeGame() {
            if (window.Telegram && Telegram.WebApp) {
                Telegram.WebApp.close();
            }
        }

        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = init;
    </script>
</body>
</html>
